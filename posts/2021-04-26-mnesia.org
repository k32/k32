#+TITLE: Mnesia internals
#+options: ^:nil

I have been studying Mnesia internals for my current job assignment,
and I figured that I may start publishing my scattered notes. There is
a lot of interesting stuff going on down there. I will update this
post with more details.

Disclaimer: I am not an OTP dev, and not a mnesia dev. Anything
that will be posted here will be derived from reading the code.

* Transaction

Transaction fun runs in the same process that calls =mnesia:transaction= function.
Most of the work during the commit stage is also done in the user process.

#+begin_src plantuml :file mnesia_trans.svg
participant tx
participant mnesia_tm

tx -> tx++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia.erl#L418 mnesia:transaction]]
tx -> tx++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L761 mnesia_tm:transaction]]

== prepare transaction ==
  tx -> mnesia_tm : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L777 start_outer]]
    note over mnesia_tm: [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L232 Create a fresh ets bag for the shadow store and a Tid]]
  tx <-- mnesia_tm : link
  tx <- mnesia_tm : {new_tid, Tid, Etab}

== run transaction ==
  tx -> tx : update mnesia_activity_state
  tx -> tx ++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L841 mnesia_tm:apply_fun]]
    tx -> tx++ #LightBlue : Apply transaction fun

... Read and write records, see "reads and writes" ...

    return Ret

== commit ==

    tx -> tx++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L1094 mnesia_tm:t_commit]]

... See "commit process in detail" ...

    return [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L844 do_commit]]

    note over tx : If result wasn't do_commit\n the tx would restart\n transaction here
  return Ret
return "{atomic, Ret}"
return "{atomic, Ret}"
#+end_src

#+RESULTS:
[[file:mnesia_trans.svg]]

*** What's inside mnesia_activity_state?

=mnesia_activity_state= is a process dictionary variable in the transaction process.

#+begin_src erlang
{mnesia,
 #tid{counter = 13, pid = <0.125.0>},
 #tidstore{store = #Ref<0.3426409509.1642725377.222071>,
           up_stores = [],
           level = 1
          }}
#+end_src

Counter is the Lamport clock (kept by =mnesia_tm= process) /at the beginning/ of the transaction.

*** What's inside the tidstore table?

#+begin_src erlang
[{{bar,1},{bar,1,2},write},
 {{foo,3},{foo,3,3}, write},
 {{locks,foo,3}, write},
 {{locks,bar,1}, write},
 {nodes, 'foo@me-emq'},
 {nodes, 'bar@me-emq'}]
#+end_src

* TODO Commit process in detail

Commit procedure also mostly happens in the caller process.
This process acts as the coordinator.

#+begin_src plantuml :file mnesia_subscr.svg
box "Original node" #White
  participant tx as tx
  participant mnesia_tm as tm
  participant mnesia_locker as locker
  participant mnesia_recover as recover
end box

box "Participant A" #LightBlue
  participant mnesia_tm as tm_a
  participant mnesia_locker as locker_a
end box

tx -> tx ++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L1094 mnesia_tm:t_commit]]
  tx -> tx : mnesia_tm:intercept_friends

  tx -> tx : mnesia_tm:arrange

  tx -> tx ++ : mnesia_tm:multi_commit(Prep)
    note over tx : Mnesia has 4 different commit protocols.\nWe only consider [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L1380 sym_trans]] here.

    tx -> tx ++ : mnesia_tm:commit_nodes
      note over tx : Get list of nodes that contain\ndisk and ram copies\nof tables affected by\nthe transaction
    return {DiskNs, RamNs}

    tx -> tx : mnesia_checkpoint:tm_enter_pending

== 1st phase of 2PC ==
    tx -> tx ++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L2071 mnesia_tm:ask_commit]]
      loop for each #commit record in #prep
        tx -\ tm_a : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L248 ask_commit]]
        tm_a -> tm_a : mnesia_checkpoint:tm_enter_pending
        tx /- tm_a : {vote_yes, Tid}

        tm_a -> tm_a : Add commit record from tx\nto the state gb_tree
      end
    return {WaitFor, Local}

    tx -> tx : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L2097 receive nodes' votes and derive outcome]]

== 2nd phase of 2PC ==
    note over tx : broadcast the outcome to\n the participants
    loop for each participant node
        tx -\ tm_a : {Tid, Outcome = do_commit}
        note over tm_a : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L273 doit_loop]]
        note over tm_a : lookup #participant record\n from the state gb_tree
    end

    tx -> tx : mnesia_recover:note_decision(Tid, committed)

    tx -> tx ++ : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L1777 mnesia_tm:do_dirty]]
      note over tx: Mnesia logs #commit record\nfor the local node.\nSee "Arrange" chapter below
      tx -> tx : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_log.erl#L227 mnesia_log:log]](#commit{})

        tm_a -> tm_a : mnesia_log:log(Commit)
        tm_a -> tm_a : mnesia_recover:note_decision(Tid, committed)

== Post-commit actions ==
      tx -> tx ++ : mnesia_tm:do_commit
        note over tx: Dump the ops to the DB,\n notify subscribers,\n etc.
        tx -> tx : mnesia_tm:do_snmp
        tx -> tx : update_ram_copies
        tx -> tx : update_disc_copies
        tx -> tx : mnesia_tm:do_update_ext
        tx -> tx : mnesia_subscr:report_activity
      return ?
    return ?

    tm_a -> tm_a : mnesia_tm:do_commit(Tid, Commit)

== Cleanup ==
    tx -> locker : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_locker.erl#L183 release_tid]]
    tm_a -> locker_a : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_locker.erl#L183 release_tid]]


    tx -\ tm : [[https://github.com/erlang/otp/blob/OTP-24.0/lib/mnesia/src/mnesia_tm.erl#L377 delete_transaction]]
  return do_commit
return do_commit

group remote cleanup
    tm_a -> tm_a : mnesia_tm:transaction_terminated
    tm_a -> tm_a : mnesia_checkpoint:tm_exit_pending(Tid)
    note over tm_a: Update the Lamport clock
end
#+end_src

#+RESULTS:
[[file:mnesia_subscr.svg]]

** Arrange

Arrange function is pretty convoluted.
Thankfully, it only uses the local data from the transaction store and the schema.
It creates a tuple of the following type:

#+begin_src erlang
mnesia:transaction(fun() -> mnesia:write({foo, 1, 2}), mnesia:write({foo, 3, 3}) end).
....
{2,
 #prep{protocol = sym_trans,
       records = [#commit{node = 'bar@localhost',
                          decision = presume_commit,
                          ram_copies = [{{foo,1},{foo,1,2},write},
                                        {{foo,3},{foo,3,3},write}],
                          disc_copies = [],disc_only_copies = [],ext = [],
                          schema_ops = []},
                  #commit{node = 'foo@localhost',decision = presume_commit,
                          ram_copies = [{{foo,1},{foo,1,2},write},
                                        {{foo,3},{foo,3,3},write}],
                          disc_copies = [],disc_only_copies = [],ext = [],
                          schema_ops = []}],
       prev_tab = foo,
       prev_types = [{'bar@localhost',ram_copies},
                     {'foo@localhost',ram_copies}],
       prev_snmp = [],
       types = [{'bar@localhost',ram_copies},
                {'foo@localhost',ram_copies}],
       majority = [],
       sync = false}}
#+end_src

The first element is the number of write/delete ops in the transaction.
This number is used to determine whether the transaction is r/o or r/w.

** What is stored in the mnesia_tm's state?

#+begin_src erlang
#state{
    coordinators = {0,nil},
    participants = %% Note: this field is a `gb_tree'. So don't mind stuff in the outer tuple
        {1,
         {#tid{counter = 32,pid = <11304.125.0>},
          #participant{
              tid = #tid{counter = 32,pid = <11304.125.0>},
              pid = nopid,
              commit =
                  #commit{
                      node = 'bar@localhost',decision = presume_commit,
                      ram_copies =
                          [{{foo,1},{foo,1,2},write},{{foo,3},{foo,3,3},write}],
                      disc_copies = [],disc_only_copies = [],ext = [],
                      schema_ops = []},
              disc_nodes = [],
              ram_nodes = ['foo@localhost','bar@localhost'],
              protocol = sym_trans},
          nil,nil}},
    supervisor = <0.99.0>,blocked_tabs = [],dirty_queue = [],
    fixed_tabs = []
  }
#+end_src


* TODO Transactional reads and writes

#+BEGIN_SRC plantuml :file mnesia_simplified.svg
box "node a"
  participant tx
  participant mnesia_locker as a
end box
box "node b"
  participant mnesia_locker as b
end box

== mnesia:write(K) ==

tx -> a : get write lock(K)
tx -> b : get write lock(K)
tx <- b : ok
tx <- a : ok

== commit transaction ==

tx -> a : ask for commit(TX)
tx -> b : ask for commit(TX)
tx <- b : ok
tx <- a : ok
tx --> tx : commit
tx -> a : release locks
tx -> b : release locks
#+END_SRC

* TODO Locker

* TODO Schema

* TODO Transaction aborts and restarts

* TODO Scalability

As should be evident from the above diagram, transaction latency is expected to grow when the number of nodes in the cluster grows.
Indeed, we observed this effect in the test with the help of [[https://www.man7.org/linux/man-pages/man8/tc-netem.8.html][netem]].

#+DATE: 2021-04-26
